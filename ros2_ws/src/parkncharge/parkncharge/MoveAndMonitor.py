import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from geometry_msgs.msg import PoseArray
import math
import heapq


class MoveToGoalAckermann(Node):

    def __init__(self):
        super().__init__('move_to_goal_ackermann')

        # Initialize goal coordinates (will be set from the topic once)
        self.goal_x = None
        self.goal_y = None

        # Current position and orientation (wait for initial odom message)
        self.current_x = None
        self.current_y = None
        self.current_orientation = None

        # Path generated by A* algorithm
        self.path = []

        # List to store the sequence of commands
        self.command_sequence = []

        # Subscribe to the /vehicle_blue/odom topic to monitor the position
        self.subscription_odom = self.create_subscription(
            Odometry,
            '/vehicle_blue/odom',
            self.odom_callback,
            10
        )

        # Subscribe to the /world/visualize_lidar_world/pose/info to get the goal
        self.subscription_pose = self.create_subscription(
            PoseArray,
            '/world/visualize_lidar_world/pose/info',
            self.pose_callback,
            10
        )

    def odom_callback(self, msg):
        # Update current position and orientation based on odometry
        position = msg.pose.pose.position
        self.current_x = position.x
        self.current_y = position.y

        orientation = msg.pose.pose.orientation
        
        # Convert quaternion to yaw
        self.current_orientation = self.quaternion_to_euler(orientation)

        if not hasattr(self, 'odom_received'):
            self.odom_received = True
            self.get_logger().info(f"Initial Position: x={self.current_x}, y={self.current_y}")

        # If the goal is set and we have odometry data, run A* if the path hasn't been planned yet
        if self.goal_x is not None and self.goal_y is not None and not self.path:
            self.path = self.a_star(self.current_x, self.current_y, self.goal_x, self.goal_y)
            # Print the planned path
            self.print_planned_path()

            # Generate movement commands after path planning
            self.generate_movement_commands()

    def quaternion_to_euler(self, orientation):
        # Convert quaternion to yaw (orientation around z-axis)
        siny_cosp = 2 * (orientation.w * orientation.z + orientation.x * orientation.y)
        cosy_cosp = 1 - 2 * (orientation.y * orientation.y + orientation.z * orientation.z)
        return math.atan2(siny_cosp, cosy_cosp)

    def pose_callback(self, msg):
        # Ensure odometry data is received before setting the goal
        if self.current_x is None or self.current_y is None:
            self.get_logger().warn("Odometry data not yet received. Waiting to set the goal.")
            return  # Exit the function until odometry is available

        # Only set the goal once
        if self.goal_x is None and self.goal_y is None:
            # Check if we have at least 3 poses
            if len(msg.poses) >= 3:
                # Extract the third pose's x and y as goal coordinates and add 2 to each
                third_pose = msg.poses[2]
                self.goal_x = third_pose.position.x + 2.0
                self.goal_y = third_pose.position.y + 2.0
                self.get_logger().info(f"Goal set to x={self.goal_x}, y={self.goal_y}")

                # Call A* to plan the path if odometry data is already available
                if self.odom_received and not self.path:
                    self.path = self.a_star(self.current_x, self.current_y, self.goal_x, self.goal_y)
                    # Print the planned path
                    self.print_planned_path()

                    # Generate movement commands after path planning
                    self.generate_movement_commands()

    def print_planned_path(self):
        # Print the entire planned path
        self.get_logger().info("Planned path:")
        for waypoint in self.path:
            self.get_logger().info(f"Waypoint: x={waypoint[0]:.2f}, y={waypoint[1]:.2f}")

    def calculate_distance(self, x1, y1, x2, y2):
        # Calculate the Euclidean distance between two points
        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

    def calculate_heading(self, x1, y1, x2, y2):
        # Calculate the angle (heading) to the goal
        return math.atan2(y2 - y1, x2 - x1)

    def a_star(self, start_x, start_y, goal_x, goal_y):
        # A* algorithm to plan the path from start to goal
        grid_size = 0.5
        start = (int(start_x // grid_size), int(start_y // grid_size))
        goal = (int(goal_x // grid_size), int(goal_y // grid_size))

        moves = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]
        open_set = []
        heapq.heappush(open_set, (0, start))

        came_from = {}
        g_score = {start: 0}
        f_score = {start: self.calculate_distance(start_x, start_y, goal_x, goal_y)}

        while open_set:
            _, current = heapq.heappop(open_set)

            if current == goal:
                return self.reconstruct_path(came_from, current)

            for move in moves:
                neighbor = (current[0] + move[0], current[1] + move[1])
                tentative_g_score = g_score[current] + self.calculate_distance(
                    current[0] * grid_size, current[1] * grid_size, neighbor[0] * grid_size, neighbor[1] * grid_size)

                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + self.calculate_distance(
                        neighbor[0] * grid_size, neighbor[1] * grid_size, goal_x, goal_y)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

        self.get_logger().error("A* failed to find a path")
        return []  # Return an empty path if no path is found

    def reconstruct_path(self, came_from, current):
        # Reconstruct the path from the came_from dictionary
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        path.reverse()

        # Filter waypoints to make them further apart and remove points behind the car
        spaced_path = []
        min_distance = 1.0  # Set the minimum distance threshold for waypoints
        direction_to_goal = self.calculate_heading(self.current_x, self.current_y, self.goal_x, self.goal_y)

        for point in path:
            current_x, current_y = point[0] * 0.5, point[1] * 0.5  # Convert back to real-world coordinates

            heading_to_point = self.calculate_heading(self.current_x, self.current_y, current_x, current_y)

            if abs(heading_to_point - direction_to_goal) < math.pi / 2:  # Forward-facing waypoint
                if not spaced_path or self.calculate_distance(spaced_path[-1][0], spaced_path[-1][1], current_x, current_y) > min_distance:
                    spaced_path.append((current_x, current_y))

        return spaced_path  # Return the filtered path

    def generate_movement_commands(self):
        """Generate and print an array of movement commands (forward, turn)."""
        commands = []
        current_orientation = self.current_orientation  # Start with the car's initial orientation

        for i in range(1, len(self.path)):
            # Calculate direction
            prev_waypoint = self.path[i - 1]
            current_waypoint = self.path[i]
            distance = self.calculate_distance(prev_waypoint[0], prev_waypoint[1], current_waypoint[0], current_waypoint[1])
            heading = self.calculate_heading(prev_waypoint[0], prev_waypoint[1], current_waypoint[0], current_waypoint[1])

            # Check if a turn is needed
            heading_diff = heading - current_orientation
            heading_diff = (heading_diff + math.pi) % (2 * math.pi) - math.pi  # Normalize to [-pi, pi]

            if abs(heading_diff) > 0.1:  # If heading difference is significant, a turn is required
                if heading_diff > 0:
                    commands.append('j')  # Left turn
                    prev_waypoint = (prev_waypoint[0] + 2, prev_waypoint[1] - 2.8)  # Update position after turn
                else:
                    commands.append('l')  # Right turn
                    prev_waypoint = (prev_waypoint[0] + 2, prev_waypoint[1] + 2.8)  # Update position after turn

            # Forward movement
            steps = int(distance // 0.2)  # Assuming 0.2 meters per forward step
            commands.extend(['i'] * steps)  # Append forward steps

            # Update orientation after the move
            current_orientation = heading

        self.command_sequence = commands
        print("Generated command sequence:", commands)
        # Call simulate_movement to print the simulated positions
        self.simulate_movement()

    def simulate_movement(self):
        """Simulate the vehicle's movement and print position after each command."""
        x, y = self.current_x, self.current_y  # Start at the initial position
        orientation = self.current_orientation  # Start with the initial orientation

        step_size = 0.2  # Each 'i' command represents 0.2 meters forward
        turn_angle = math.radians(15)  # Each turn command 'j' or 'l' rotates by 15 degrees

        print("Simulating movement:")
        for command in self.command_sequence:
            if command == 'i':
                # Move forward in the direction of the current orientation
                x += step_size * math.cos(orientation)
                y += step_size * math.sin(orientation)
            elif command == 'j':
                # Turn left by 15 degrees
                orientation += turn_angle
            elif command == 'l':
                # Turn right by 15 degrees
                orientation -= turn_angle

            # Print the current simulated position and orientation
            print(f"Command: {command}, Position: x={x:.2f}, y={y:.2f}, Orientation: {math.degrees(orientation):.2f}°")

    def stop_vehicle(self):
        # Send a stop command by setting both linear and angular velocities to zero
        stop_cmd = Twist()
        stop_cmd.linear.x = 0.0
        stop_cmd.angular.z = 0.0

        # Send multiple stop commands to ensure the vehicle halts and clears any queued commands
        for _ in range(5):
            self.publisher_.publish(stop_cmd)

        self.get_logger().info("Reached the goal and stopped.")


def main(args=None):
    rclpy.init(args=args)

    # Create and run the node
    move_to_goal_ackermann = MoveToGoalAckermann()

    try:
        rclpy.spin(move_to_goal_ackermann)
    except KeyboardInterrupt:
        # Ensure vehicle stops when the program is interrupted
        move_to_goal_ackermann.stop_vehicle()
        pass

    move_to_goal_ackermann.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
